use super::Tag;
use crate::{
    errors::{Bound, DeclensionErr},
    morph::grammemes::{Grammem, ParteSpeech},
};

/// Буквы алфавита, необходимые чтобы выстраивать границу префиксного поиска до _следующей буквы алфавита_.
const ALPHABET: [char; 32] = [
    'а', 'б', 'в', 'г', 'д', 'е', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т',
    'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я',
];

/// Для некоторых нормализованных форм характерно чередование букв в префиксе.
/// Для того, чтобы найти все слова для спряжений/склонений, нам необходимо
/// проверить также префиксы с чередованием.
///
/// ## WARN!
/// Собирается в функции `test_infrastructure::test_form_first_chars`.
/// Важно собирать эти значения, если меняются связи между леммами.
const DIFF: [(&str, &str); 252] = [
    ("брать", "бе"),
    ("вить", "вь"),
    ("вить", "ве"),
    ("сбиться", "со"),
    ("петь", "по"),
    ("вбить", "во"),
    ("рот", "рт"),
    ("ты", "те"),
    ("ты", "то"),
    ("тьма", "те"),
    ("айка", "ае"),
    ("что-то", "че"),
    ("так", "т"),
    ("питься", "пь"),
    ("питься", "пе"),
    ("содраться", "сд"),
    ("лед", "ль"),
    ("сие", "се"),
    ("честься", "чт"),
    ("опереть", "об"),
    ("искать", "ищ"),
    ("исшить", "из"),
    ("день", "дн"),
    ("яйцо", "яи"),
    ("рыться", "ро"),
    ("удить", "уж"),
    ("сжечь", "со"),
    ("око", "оч"),
    ("человек", "лю"),
    ("переть", "пр"),
    ("счесть", "со"),
    ("они", "их"),
    ("они", "ни"),
    ("они", "им"),
    ("что-либо", "че"),
    ("пить", "пь"),
    ("пить", "пе"),
    ("молоть", "ме"),
    ("слать", "шл"),
    ("зло", "зо"),
    ("демейк", "ди"),
    ("соваться", "су"),
    ("чтоб", "шт"),
    ("чтоб", "шо"),
    ("пойти", "пш"),
    ("переться", "пр"),
    ("раздать", "ро"),
    ("уняться", "уй"),
    ("ребенок", "де"),
    ("себя", "со"),
    ("ухо", "уш"),
    ("опереться", "об"),
    ("расти", "ро"),
    ("класть", "ло"),
    ("сесть", "ся"),
    ("взять", "во"),
    ("жевать", "жу"),
    ("истереть", "из"),
    ("мьютить", "мю"),
    ("то", "т"),
    ("гнать", "го"),
    ("год", "ле"),
    ("год", "гг"),
    ("слить", "со"),
    ("нквд", "эн"),
    ("жечь", "жг"),
    ("жечь", "жж"),
    ("щи", "ще"),
    ("щи", "ща"),
    ("мять", "мн"),
    ("кто", "ко"),
    ("кто", "ке"),
    ("мыться", "мо"),
    ("широта", "ш"),
    ("заря", "зо"),
    ("искаться", "ищ"),
    ("ехать", "ед"),
    ("ехать", "ез"),
    ("биться", "бь"),
    ("биться", "бе"),
    ("подонок", "па"),
    ("выть", "во"),
    ("петься", "по"),
    ("мстить", "мщ"),
    ("смять", "со"),
    ("литься", "ль"),
    ("литься", "ле"),
    ("испить", "из"),
    ("быть", "ес"),
    ("быть", "су"),
    ("быть", "бу"),
    ("быть", "е"),
    ("стереться", "со"),
    ("унять", "уй"),
    ("уйти", "уш"),
    ("счесться", "со"),
    ("сжать", "со"),
    ("мяться", "мн"),
    ("рыть", "ро"),
    ("изойти", "ис"),
    ("мыть", "мо"),
    ("стереть", "со"),
    ("ия", "ии"),
    ("ия", "ию"),
    ("ия", "ие"),
    ("ия", "ий"),
    ("она", "ее"),
    ("она", "не"),
    ("она", "ей"),
    ("она", "ею"),
    ("она", "ея"),
    ("оно", "ег"),
    ("оно", "не"),
    ("оно", "ем"),
    ("оно", "им"),
    ("оно", "ни"),
    ("что", "шт"),
    ("что", "че"),
    ("что", "ча"),
    ("что", "чо"),
    ("что", "шо"),
    ("я", "ме"),
    ("я", "мн"),
    ("кто-нибудь", "ко"),
    ("кто-нибудь", "ке"),
    ("впить", "во"),
    ("пень", "пн"),
    ("звать", "зо"),
    ("сегвей", "си"),
    ("ввить", "во"),
    ("что-нибудь", "че"),
    ("лить", "ль"),
    ("лить", "ле"),
    ("влить", "во"),
    ("смяться", "со"),
    ("вобраться", "вб"),
    ("тереться", "тр"),
    ("вшить", "во"),
    ("пес", "пс"),
    ("впереться", "во"),
    ("шиться", "шь"),
    ("шиться", "ше"),
    ("драться", "де"),
    ("согнать", "сг"),
    ("влиться", "во"),
    ("ая", "аи"),
    ("ая", "ае"),
    ("ая", "аю"),
    ("ая", "ай"),
    ("спереться", "со"),
    ("вмять", "во"),
    ("узить", "уж"),
    ("истереться", "из"),
    ("драть", "де"),
    ("вжать", "во"),
    ("спереть", "со"),
    ("впиться", "во"),
    ("услать", "уш"),
    ("впереть", "во"),
    ("честь", "чт"),
    ("честь", "чл"),
    ("ретейлер", "ри"),
    ("совать", "су"),
    ("свиться", "со"),
    ("век", "вв"),
    ("лен", "ль"),
    ("идти", "ше"),
    ("идти", "шл"),
    ("бить", "бь"),
    ("бить", "бе"),
    ("слаться", "шл"),
    ("рожь", "рж"),
    ("лезть", "по"),
    ("лоб", "лб"),
    ("содрать", "сд"),
    ("гнаться", "го"),
    ("жать", "жн"),
    ("жать", "жм"),
    ("вогнать", "вг"),
    ("вы", "ва"),
    ("есться", "ем"),
    ("есться", "ед"),
    ("есться", "еш"),
    ("есться", "ел"),
    ("есться", "ев"),
    ("кто-то", "ко"),
    ("кто-то", "ке"),
    ("сон", "сн"),
    ("сжаться", "со"),
    ("ныть", "но"),
    ("свить", "со"),
    ("спиться", "со"),
    ("ковать", "ку"),
    ("кто-либо", "ко"),
    ("кто-либо", "ке"),
    ("дно", "до"),
    ("браться", "бе"),
    ("сшить", "со"),
    ("жечься", "жг"),
    ("жечься", "жж"),
    ("опить", "об"),
    ("мох", "мх"),
    ("вобрать", "вб"),
    ("он", "ег"),
    ("он", "не"),
    ("он", "ем"),
    ("он", "им"),
    ("он", "ни"),
    ("удиться", "уж"),
    ("коваться", "ку"),
    ("вошь", "вш"),
    ("ребеночек", "де"),
    ("ров", "рв"),
    ("спить", "со"),
    ("шов", "шв"),
    ("узиться", "уж"),
    ("жеваться", "жу"),
    ("лгать", "лж"),
    ("александрович", "са"),
    ("ложь", "лж"),
    ("жаться", "жм"),
    ("втереться", "во"),
    ("молоться", "ме"),
    ("опиться", "об"),
    ("мы", "на"),
    ("мереть", "мр"),
    ("втереть", "во"),
    ("вжаться", "во"),
    ("лев", "ль"),
    ("слиться", "со"),
    ("тереть", "тр"),
    ("сбить", "со"),
    ("виться", "вь"),
    ("виться", "ве"),
    ("мейл", "мэ"),
    ("зваться", "зо"),
    ("изостлать", "ис"),
    ("лечь", "ля"),
    ("шить", "шь"),
    ("шить", "ше"),
    ("как", "к"),
    ("вмяться", "во"),
    ("идтись", "шл"),
    ("есть", "ем"),
    ("есть", "ед"),
    ("есть", "еш"),
    ("есть", "ел"),
    ("есть", "ев"),
    ("взяться", "во"),
    ("ютиться", "юч"),
    ("хентай", "хэ"),
    ("сжечься", "со"),
];

/// Поиск алфавитных границ префиксов для ограничения прохода по Fst::Stream.
///
/// Для наречий и прилагательных проверяются также их приставки
/// "по-" и "наи-" для сравнительной и превосходной степеней.
///
/// ### Example
/// "стали" -> ищутся префиксы от "ст" до "су".
/// "лучший" -> ищутся префиксы от "лу" до "лф", "полу" до "полф", "наилу" до "наилф".
pub fn alphabet_stream(
    word: &str,
    normal_form: &str,
    tag: Tag,
) -> Result<Vec<(String, Option<String>)>, DeclensionErr> {
    // todo после нормализации
    if [
        ParteSpeech::AdjectiveFull,
        ParteSpeech::AdjectiveShort,
        ParteSpeech::Comparative,
        ParteSpeech::Adverb,
    ]
    .contains(&Grammem::pos_in_tag(&tag).unwrap_or_else(|| panic!("No ParteSpeech in {tag:?}")))
    {
        alphabet_vicino_po_nai(word, normal_form)
    } else {
        alphabet_vicino(word, normal_form)
    }
}

/// Взятие следующей буквы алфавита для конечной границы префиксного поиска.
fn next_char(char: &char) -> Result<Option<String>, DeclensionErr> {
    let char_id = ALPHABET
        .binary_search(char)
        .map_err(|_| DeclensionErr::BinaryChar(*char))?;
    if char_id == ALPHABET.len() - 1 {
        Ok(None)
    } else {
        let last = ALPHABET
            .get(char_id + 1)
            .ok_or_else(|| DeclensionErr::OutOfBound {
                idx: (char_id + 1) as u64,
                vec: Bound::Alphabet,
            })?
            .to_string();
        Ok(Some(last))
    }
}

/// Взятие префиксных пар для прохода по `fst::Stream`.
///
/// Если у нормализованной формы и других вариаций слова есть чередования в префиксе,
/// будут взяты все инварианты.
///
/// Если нет возможности найти "следующую по алфавиту" (например, для 'я'), то
/// возвращается None, сигнализируя `fst::Stream`, что необходимо брать `less-or-equal` от начальных букв.
pub(crate) fn alphabet_vicino(
    word: &str,
    normal_form: &str,
) -> Result<Vec<(String, Option<String>)>, DeclensionErr> {
    let mut result = Vec::new();

    let (inizio, next_chars) = take_chars(word)?;
    result.push((inizio, next_chars));

    for (_, diff) in DIFF.iter().filter(|pair| pair.0 == normal_form) {
        let (diff_inizio, diff_next_chars) = take_chars(diff)?;
        result.push((diff_inizio, diff_next_chars))
    }

    Ok(result)
}

/// Для кратких и полных прилагательных есть сравнительная степень, образующаяся за счет добавления префиксов "по-" или "наи-".
/// Например, лучший -> наилучший, хуже -> похуже.
///
/// Для того, чтобы найти все формы от прилагательных (или обратно), нам потребуется смотреть пары префиксов,
/// включая вариации с "по-" и "наи-".
pub(crate) fn alphabet_vicino_po_nai(
    word: &str,
    normal_form: &str,
) -> Result<Vec<(String, Option<String>)>, DeclensionErr> {
    let mut result = Vec::new();

    // todo слова с по/наи как часть корня
    let word = if let Some(word) = word.strip_prefix("по") {
        word
    } else if let Some(word) = word.strip_prefix("наи") {
        word
    } else {
        word
    };

    let (inizio, next_chars) = take_chars(word)?;
    let (nai, nai_next) = (
        format!("наи{inizio}"),
        next_chars.clone().map(|next| format!("наи{next}")),
    );
    let (po, po_next) = (
        format!("по{inizio}"),
        next_chars.clone().map(|next| format!("по{next}")),
    );

    result.push((inizio, next_chars));
    result.push((nai, nai_next));
    result.push((po, po_next));

    for (_, diff) in DIFF.iter().filter(|pair| pair.0 == normal_form) {
        let (diff_inizio, diff_next_chars) = take_chars(diff)?;
        result.push((diff_inizio, diff_next_chars))
    }

    Ok(result)
}

/// Функция берет две первые буквы слова (если они имеются) как начало стрима и
/// эти же две буквы, но вторую из них меняя на следующую по алфавиту, для конца стрима.
///
/// Если нет возможности найти "следующую по алфавиту" (например, для 'я'), то
/// возвращается None, сигнализируя стриму fst, что необходимо брать less-or-equal от начальных букв.
fn take_chars(word: &str) -> Result<(String, Option<String>), DeclensionErr> {
    let mut word_chars = word.chars();

    let first = word_chars.next().ok_or(DeclensionErr::EmptyWord)?;
    let second = word_chars.next();

    let mut first_pair = String::from(first);
    let mut next_chars = String::from(&first.to_string());

    let next_chars = if let Some(second) = second {
        first_pair.push(second);

        match next_char(&second)? {
            Some(char) => {
                next_chars.push_str(&char);
                Some(next_chars)
            }
            None => None,
        }
    } else {
        next_char(&first)?
    };

    Ok((first_pair, next_chars))
}
#[cfg(test)]
mod test {
    use super::*;
    use itertools::Itertools;
    use test_case::test_case;

    #[test_case("больше", "больше", &[("бо", "бп"), ("наибо", "наибп"), ("побо", "побп")])]
    #[test_case("получше", "хороший", &[("лу", "лф"), ("наилу", "наилф"), ("полу", "полф")])]
    #[test_case("опаснее", "опасно", &[("оп", "ор"), ("наиоп", "наиор"), ("пооп", "поор")])]
    #[test_case("худшее", "худший", &[("ху", "хф"), ("наиху", "наихф"), ("поху", "похф")])]
    #[test_case("похуже", "плохо", &[("ху", "хф"), ("наиху", "наихф"), ("поху", "похф")])]
    fn test_po_nai(word: &str, normal_form: &str, result: &[(&str, &str)]) {
        assert_eq!(
            alphabet_vicino_po_nai(word, normal_form)
                .unwrap()
                .iter()
                .map(|(k, l)| (k.as_str(), l.as_ref().unwrap().as_str()))
                .collect_vec(),
            result
        )
    }
}
